Spring Notes

Goals of Spring
    - Lightweight development with Java POJOS
    - Dependency injection to promote loose coupling
    - Declarative programming with Aspect-Oriented-Programming (AOP)
    - Minimize boilerplate Java code

Core Container
    1) Beans
    2) Core
    3) SpEL
    - Spring Expression Language
    4) Context

Summary:
    - Factory for creating beans
    - Manage bean dependencies

Infrastructure
    1) AOP
    2) Aspects
    3) Instrumentation
    4) Messaging

    Summary:
    - Aspect Oriented Programming (Logging, security, transactions, instrumentations, etc that you can apply these services to your objects in a declarative fashion )
    
Data Access Layer
    1) JDBC
    2) ORM
    3) Transactions
    4) OXM
    5) JMS

    Summary: 
    - Communicating with databases.
    - JDBC Helper classes (can reduce your jdbc code by 50%).
    - ORM to relational Mapping and Integration with Hibernate and JPA
    - Java Message Service allows you to send messages to a message queue asynchronously (many helper classes to reduce code by 50%)
    
Web Layer
    1) Servlet
    2) WebSocket
    3) Web
    4) Portlet

    Summary: 
    - All web related classes
    - Home of the Spring MVC module
    
    
Spring Projects
    - Additional Spring modules built-on top of the core Spring Framework
    - Only use what you need...
    - Spring Cloud, Spring Data
    - Spring Batch, Spring Security
    - Spring for Android, Spring Web Flow
    - Spring Web Services, Spring LDAP
    
Tomcat
    MacOS Installation
        1) Download the .tar
        2) Install it
        3) Unzip and move it to your preferred directory
        4) cd in to the directory
        5) bin/startup.sh (to start the server)
        6) go to localhost:8080
        7) bin/shutdown.sh (to shut down server)
        
Spring Jar files
    https://repo.spring.io/release/org/springframework/spring/
    This method does not require Maven. Download the dist and save it somewhere on your computer. Go to lib and copy all the JARs and then make a new folder called lib in Eclipse. Paste the JARs in that new folder. Then go to the project properties by right clicking and hitting properties on the main folder. Go to Java Build Path, Librariers, Add JARS.
    
Inversion of Control
    This is important!
    - The approach of outsourcing construction and management of objects.
    
Spring Container
    1) Primary functions
    - Create and manage objects (Inversion of Control)
    - Inject object's dependencies (Dependency Injection)

Configuring Spring Container
    1) XML configuration file (legacy, but most legacy apps still use this)
    2) Java Annotations (modern)
    3) Java Source Code (modern)
    Spring Development Process
    1) Configure your Spring Beans
    2) Create a Spring Container
    3) Retrieve Beans from Spring Container
    
    Step 1: Configure your Spring Beans
        File: applicationContext.xml

        <beans ...>
          <bean id="myCoach"     
        class="com.luv2code.springdemo.BaseballCoach">
          </bean>
        </beans>
        
Step 2: Create a Spring Container 
    - Spring container is generically known as ApplicationContext
    - Specialized implementations
    -- ClassPathXmlApplicationContext
    -- AnnotationConfigApplicationContext
    -- GenericWebApplicationContext
    -- others...

    Ex) 
      ClassPathXmlApplicationContext context = new ClassPAthXmlApplicationContext("applicationContext.xml");
      
Step 3: Retrieve Beans from Container
    // create a spring container
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

    // retrieve bean from spring container, the id must match what we are passing in... myCoach
    Coach theCoach = context.getBean("myCoach", Coach.class);
    
    The first argument is the id in applicationContext.xml and the second argument is the Interface
    
FAQ: What is a Spring Bean?

A "Spring Bean" is simply a Java object.

When Java objects are created by the Spring Container, then Spring refers to them as "Spring Beans".

Spring Beans are created from normal Java classes .... just like Java objects.


---

In the early days, there was a term called "Java Beans". Spring Beans have a similar concept but Spring Beans do not follow all of the rigorous requirements of Java Beans.

---


Dependency Injection
    - The dependency inversion principle.
    - The client delegates to calls to another object the responsibility of providing dependencies.
    Basically...
    1) Give me a "Car" object
    ->
    2) Car Factory, technicians will assemble the car for you. They will inject all the "dependency" (same thing as "helper objects") for you.
    3) Give "Car" to you

    Summary: You simply outsource the construction to an external entity.
    
Injection Types
    - There are many types of injection with Spring
    - We will cover the two most common:
    1) Constructor Injection
    2) Setter Injection
    - Autowiring will come later...

-----------------
    
Development Process - Contructor Injection
    1) Define the dependency interface and class
    2) Create a constructor in your class for injections
    3) Configure the dependency injection in Spring config file    

Step 1: Define the dependency interface and class
    File: FortuneService.java
     public interface FortuneService {
      public String getFortune();
    }

    File: HappyFortuneService.java
      public class HappyFortuneService implements FortuneService {
      public String getFortune() {
        return "Today is your lucky day!";
      }
    }


Step 2: Create a constructor
    File: BaseballCoach.java
    public class BaseballCoach implements Coach {

      // define field
      private FortuneService fortuneService;

      // define constructor
      public BaseballCoach(FortuneService theFortuneService) {
        fortuneService = theFortuneService;
      }
    }
    
Step 3: Configure the dependency injection in Spring config file
    File: applicationContext.xml
    <bean id="myFortuneService" class="com.alex.HappyFortuneService">
    </bean>

    <bean id="myCoach" class="com.alex.BaseballCoach">
      <cosntructor-arg ref="myFortuneService" />
    </bean>

    a) Define the dependency/helper
    b) Inject that dependency into our class using ref (constructor injection)
    
-----------------
    
Setter Injection
    - Inject dependencies by calling setter method(s) on your class
    
Development Process - Setter Injection
    1) Create setter method(s) in your class for injections
    2) Configure the dependency injection in Spring config file
    
Step 1: Create the setter method(s) in your class for injections
    File: CricketCoach.java
    public class CricketCoach implements Coach {
      private FortuneService fortuneService;

      public CricketCoach() {
      }

      // Called by Spring during setter injection
      public void setFortuneService(FortuneService fortuneService) {
        this.fortuneService = fortuneService;
      }

    }
    
**Step 2: Configure the dependency injection in Spring config file**
    ```xml
    <bean id="myFortuneService" class="com.alex.HappyFortuneService">
    </bean>

    <bean id="myCricketCoach" class="com.alex.CricketCoach">
      <property name="fortuneService" ref="myFortuneService"/>
    </bean>
    ```
    
**How Spring Processes your Config File**
```xml
<bean id="myFortuneService" class="com.alex.HappyFortuneService">
</bean>
```
-> Spring Framework
```java
HappyFortuneService myFortuneService = new HappyFortuneService();
```

-----------------

**Injecting Literal Values**
    Example... injecting strings such and team name or email address into the CricketCoach
    **Development Process**
    1) Create setter method(s) in your class for injections
    2) Configure the injection in Spring config file

**Step 1:**
```java
public class CricketCoach implements Coach {
  private String emailAddress;
  private String team;

  // Create Setter methods
  public void setEmailAddress(String emailAddress) {
    // ....
  }
  public void setTeam(String team) {
    // ...
  }
}
```

**Step 2:**
```xml
 <bean id="myCricketCoach" class="com.alex.CricketCoach">
  <property name="fortuneService" ref="myFortuneService" />
  <property name="emailAddress" value="alex@email.com" />
  <property name="team" value="Team One" />
 </bean>
```

**Injecting Values from a Properties File**
1) Create Properties File
2) Load Properties File in Spring config file
3) Reference values from Properties File

**Step 1:**
File: sport.properties
name and value pairs
```
foo.email=alex@email.com
foo.team=Extreme Challengers
```

**Step 2: **
File: applicationContext.xml
```xml
  <context:property-placeholder location="classpath:sport.properties" />
```

**Step 3:**
File: applicationContext.xml
```xml
<bean id="myCricketCoach" class="com.alex.CricketCoach">
...
<property name="emailAddress" value="${foo.email}" />
<property name="team" value="${foo.team}" />
</bean>
```

-----------------

**Bean Scopes**
- Scope refers to the lifecycle of a bean
- How long does the bean live?
- How many instances are created?
- How is the bean shared?

**Default Scope: Singleton**
```xml
<beans .../>
  <bean id="myCricketCoach" class="com.alex.CricketCoach" ...>
  </bean>
</bean>
```

**What Is a Singleton?**
- Spring Container creates only one instance of the bean, by default
- It is cached in memory
- All requests for the bean will return a SHARED reference to the SAME bean

Best used when you want stateless beans aka don't maintain any state.

**Explicitly Specify Bean Scope**
```xml
<beans .../>
  <bean id="myCricketCoach" class="com.alex.CricketCoach" scope="singleton">
  </bean>
</bean>
```

**Prototype Scope Example**
Prototype scope: new object for each request
```xml
<beans ...>
  <bean id="myCoach" class="com.alex.TrackCoach" scope="prototype">
  ...
  </bean>
</beans
```
Good for keeping track of stateful data.

-----------------

Bean Lifecycle
    1) Container Started
    2) Bean Instantiated
    3) Dependencies Injected
    4) Internal Spring Processing
    5) Your Custom Init Method
    6) Bean is Ready For Use / Container Is Shutdown
    7) Your Custom Destroy Method
    8) STOP
    
Bean Lifecycle Methods / Hooks
    - You can add custom code during bean initialization
      - Calling custom business logic methods
      - Setting up handles to resources (db, sockets, file, etc)
    - You can add custom code during bean destruction
      - Calling custom business logic methods
      - Setting up handles to resources (db, sockets, file, etc)
      
**Init: method configuration**
    ```xml
    <beans ...>
      <bean id="myCoach" class="com.alex.TrackCoach" init-method="doMyStartupStuff" ...>
      </bean>
    </beans>
    ```

**Destroy: method configuration**
    ```xml
    <beans ...>
      <bean id="myCoach" class="com.alex.TrackCoach" destroy-method="doMyStartupStuff" ...>
      </bean>
    </beans>
    ```
    
Development Process
    1) Define your methods for init and destroy
    2) Configure the method names in Spring config file
    
    
Special Note about init and destroy Method Signatures

    When using XML configuration, I want to provide additional details regarding the method signatures of the init-method  and destroy-method .

    Access modifier
    The method can have any access modifier (public, protected, private)

    Return type
    The method can have any return type. However, "void' is most commonly used. If you give a return type just note that you will not be able to capture the return value. As a result, "void" is commonly used.

    Method name
    The method can have any method name.

    Arguments
    The method can not accept any arguments. The method should be no-arg.   

------

**What are Java Annotations?**
    - Special labels/markers added to Java classes
    - Provide meta-data about the class
    - Processed at compile time or run-time for special processing


**Why Spring Configuration with Annotations?**
    - XML configuration can be verbose
    - Configure your Spring beans with Annotations
    - Annotations minimizes the XML configuration
    
**Scanning for Component Classes**
    - Spring will scan your Java classes for special annotations
    - Automatically register the beans in the Spring container
    
**Development Process**
    1) Enable component scanning in Spring config file
    2) Add the @Component Annotation to your Java classes
    3) Retrieve bean from Spring container

**Step 1:** 
```xml
<beans ...>
  <context:component-scan base-package="com.alex" />
</beans>
```

**Step 2**
```java
@Component("thatSillyCoach")
public class TennisCoach implements Coach {
  @Override
  public String getDailyWorkout() {
    return "Practice your backhand valley";
  }
}
```

**Step 3**
    - Same coding as before... nothing changes.
    ```java
    Coach theCoach = context.getBean("thatSillyCoach", Coach.class);
    ```

    Spring also supports Default Bean IDs
    - Default bean id: the class name, make first letter lower-case

    Class Name
    TennisCoach

    ->

    Default Bean Id
    tennisCoach
    
------
    
**What is Spring AutoWiring?**
- For dependency injection, Spring can use auto wiring.
- Spring will look for a class that *matches* the property
    - *matches* by type: class or interface
- Spring will inject it automatically... hence it is autowired

**Autowiring Example**
- Injecting FortuneService into a Coach implementation
- Spring will scan @Components
- Any one implements FortuneService interface???
- If so, let's inject them. For example: HappyFortuneService

**Autowiring Injection Types**
- Constructor Injection
- Setter Injection
- Field Injections

**Development Process - Constructor Injection**
1) Define the dependency interface and class
2) Create a constructor in your class for injections
3) Configure the dependency injection with @Autowired Annotation
    
**Step 1:**
File: FortuneService.java
```java
public interface FortuneService {
  public String getFortune();
}
```
File: HappyFortuneService.java
```java
@Component
public class HappyFortuneService implements FortuneService {
  public String getFortune() {
    return "Today is your lucky day!"
  }
}
```

**Step 2**
File: TennisCoach.java
```java
@Component
public class TennisCoach implements Coach {
  private FortuneService fortuneService;

  public TennisCoach(FortuneService theFortuneService) {
    fortuneService = theFortuneService;
  }
}
```

**Step 3**
File: TennisCoach.java
```java
@Component
public class TennisCoach implements Coach {
  private FortuneService fortuneService;

  @Autowired
  public TennisCoach(FortuneService theFortuneService) {
    fortuneService = theFortuneService;
  }
}
```

------
AUTOWIRING
FAQ: What if there are multiple FortuneService implementations?

When using autowiring, what if there are multiple FortuneService implementations? Like in the image below?
---
ANSWER

Spring has special support to handle this case. Use the @Qualifier annotation.

---------


**Setter Injection**
- Inject dependencies by calling setter method(s) on your class

**Autowiring Example**
- Injecting FortuneService into a Coach implementation
- Spring will scan @Components
- Any one implements FortuneService interface???
- If so, let's inject them. For example: *HappyFortuneService*
    
**Development Process - Setter Injection**
    1) Create setter method(s) in your class for injections
    2) Configure the dependency injection with @Autowired Annotation

    **Step 1**
    File: TennisCoach.java
    ```java
    @Component
    public class TennisCoach implements Coach {
      private FortuneService fortuneService;

      public TennisCoach() {
      }

      public void setFortuneService(FortuneService fortuneService) {
        this.fortuneService = fortuneService;
      }
      ...
    }
    ```

    **Step 2**
    File: TennisCoach.java
    ```java
    @Component
    public class TennisCoach implements Coach {
      private FortuneService fortuneService;

      public TennisCoach() {
      }

      @Autowired
      public void setFortuneService(FortuneService fortuneService) {
        this.fortuneService = fortuneService;
      }
      ...
    }
    ```

**Method Injection**
    - Inject dependencies by calling ANY method on your class

    Simply give: 
    ```java
    @Autowired
    ```

    **Step 2**
    File: TennisCoach.java
    ```java
    @Component
    public class TennisCoach implements Coach {
      private FortuneService fortuneService;

      public TennisCoach() {
      }

      @Autowired
      public void doSomeCrazyStuff(FortuneService fortuneService) {
        this.fortuneService = fortuneService;
      }
      ...
    }
    ```
    
---------------

**Field Injection with Annotations and Autowiring**
    - Inject dependencies by setting field values on your class directly (even private fields)
    - Accomplished by using Java Reflection

**Development Process - Field Injection**
    1) Configure the dependency injection with Autowired Annotation
    - Applied directly to the field
    - No need for setter methods

**Step 1**
    File: TennisCoach.java
    ```java
    public class TennisCoach implements Coach {
      @Autowired
      private FortuneService fortuneService;

      public TennisCoach() {
      }

      // no need for setter methods
      ...
    }
    ```

    
-----------
**Multiple FortuneService Implementations**
    Solution: Be specific - @Qualifier
        ```java
        public class TennisCoach implements Coach {

          @Autowired
          @Qualifier("happyFortuneService")
          private FortuneService fortuneService;

          ...
        }
        ```

**Injection Types**
Can apply **@Qualifier** annotation to:
- Constructor Injection
- Setter injection methods
- Field injection

---------
**Explicitly Specify Bean Scope**
    ```java
    @Component
    @Scope("singleton")
    public class TennisCoach implements Coach{
    }
    ```
**Bean Lifecycle Method Annotations**
Development Process
    1) Define your methods for init and destroy
    2) Add annotations: @PostConstruct and @PreDestroy

Java 9 + Errors with @PostConstruct and @PreDestroy
    https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/9120288#content

**Special Note about Destroy Lifecycle and Prototype Scope**
Here is a subtle point you need to be aware of with "prototype" scoped beans.

For "prototype" scoped beans, Spring does not call the @PreDestroy method.  Gasp!  
https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/5389290#content   
    
    
    
------------
    
**Spring Configuration with Java Code**
    - No XML
    - Configure Spring Container with Java

**3 Ways of Configuring Spring Container**
    1) Full XML Config
    2) XML Component Scan
    3) Java Configuration Class

**Development Process**
    1) Create a Java class and annotate as **@Configuration**
    2) Add component scanning support **@ComponentScan** (optional)
    3) Read Spring Java configuration class
    4) Retrieve bean from Spring container
    
    **Step 1:**
    ```java
    @Configuration
    public class SportConfig {
    }
    ```
    **Step 2:**
    ```java
    @Configuration
    @ComponentScan("com.alex")
    public class SportConfig {
    }
    ```
    **Step 3:**
    In our main
    ```java
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SportConfig.class);
    ```
    **Step 4:**
    ```java
    Coach theCoach = context.getBean("tennisCoach", Coach.class);
    ```
------------------- 
    
**Defining Spring Beans with Java Code**

**Development Process**
1) Define method to expose bean
2) Inject bean dependencies
3) Read Spring Java configuration class
4) Retrieve bean from Spring container

**Step 1**
No component scan. Define each bean individually.
```java
@Configuration
public class SportConfig() {

  @Bean
  public Coach swimCoach() {
    SwimCoach mySwimCoach = new SwimCoach();

  return mySwimCoach;
  }
}
```
**Step 2**
```java
@Configuration
public class SportConfig() {

  // Create instance of HappyFortuneService and return it
  @Bean
  public FortuneService happyFortuneService() {
    return new HappyFortuneService();
  }

  // Inject happyFortuneService
  @Bean
  public Coach swimCoach() {
    SwimCoach mySwimCoach = new SwimCoach(happyFortuneService());

  return mySwimCoach;
  }
}
```
**Step 3**
```java
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SportConfig.class); 
```
**Step 4**
The beanId "swimCoach" is the method name we defined in the Bean.
```java
Coach theCoach = context.getBean("swimCoach", Coach.class);
```

--------------
**Injecting Values from Properties File**

**Development Process**
1) Create Properties File
2) Load Properties File in Spring config
3) Reference values from Properties File

**Step 1**
File: sport.properties
```
foo.email=alex@email.com
foo.team=Awesome Java Coders
```
**Step 2**
Load the props file
```java
@Configuration
@PropertySource("classpath:sport.properties")
public class SportConfig {
  ...
}
```
**Step 3**
File: SwimCoach.java
```java
public class SwimCoach implements Coach {
  @Value("${foo.email}")
  private String email;

  @Value("${foo.team}")
  private String team;
  
  ...
}
```
    
---------------

**What is Spring MVC?**
- Framework for building web applications in Java
- Based on Model-View-Controller design pattern
- Leverages features of the Core Spring Framework (IoC, DI)
    
**Spring MVC Benefits**
- The Spring way of building web app UIs in Java
- Leverage a set of reusable UI components
- Help manage application state for web requests
- Process form data: validation, conversion, etc.
- Flexible configuration for the view layer

**Spring MVC Documentation**
https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html    
    
    
**Spring MVC Front Controller**

- Front controller known as **DispatcherServlet**
    - Part of the Spring Framework
    - Already developed by Spring Dev Team

- You will create
    - Model Objects
    - View tempates
    - Controller classes

**Controller**
- Code created by the developer
- Contains your business logic
    - Handle the request
    - Store / retrieve data (db, webservice...)
    - Place data in model

- Send to appropriate view template

**Model**
- Model: contains your data
- Store/retrieve data via backend systems
    - database, web service, etc...
    - Use a Spring bean if you like
- Place your data in the model
    - Data can be any Java object/collection

**View Template**
- Spring MVC is flexible
    - Supports many view templates
- Most common is JSP + JSTL
- Developer creates a page
    - Displays data
- Other view templates supported
    - Thymeleaf, Groovy
    - Velocity, Freemarker, etc...
- For details, see:
    - www.luv2code.com/spring-mvc-views
    
----------------

**Spring MVC Configuration Process - Part 1**
    Add configurations to file: **WEB-INF/web.xml**
    1) Configure Spring MVC Dispatcher Servlet
    2) Set up URL mappings to Spring MVC Dispatcher Servlet

**Spring MVC Configuration Process - Part 2**
    Add configurations to file: **WEB-INF/spring-mvc-demo-servlet.xml**
    3) Add support for Spring component scanning
    4) Add support for conversion, formatting and validation
    5) Configure Spring MVC View Resolver
    
    **Step 1**
    File: web.xml
    ```xml
    <web-app>
      <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

        <init-param>
          <param-name>contextConfigLocation</param-name>
          <param-value>/WEB-INF/spring-mvc-demo-servlet.xml</param-value>
        </init-param>

        <load-on-startup>1</load-on-startup>

      </servlet>
    </web-app>
    ```
    **Step 2**
    File: web.xml
    ```xml
    <web-app>
      <servlet>
        <servlet-name>dispatcher</servlet-name>
         ...
      </servlet>

      <!--Step 2 - servlet-names must match -->
      <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
      </servlet-mapping>
    </web-app>
    ```
    **Step 3**
    ```xml
    <beans>

      <!-- Step 3: Add support for component scanning -->
      <context:component-scan base-package="com.alex" />

    </beans>
    ```
    **Step 4**
    ```xml
    <beans>

      <!-- Step 3: Add support for component scanning -->
      <context:component-scan base-package="com.alex" />

      <!-- Step 4: Add support for conversion formatting and validation-->
      <mvc:annotation-driven />

    </beans>
    ```
    **Step 5**
    ```xml
    <beans>

      <!-- Step 3: Add support for component scanning -->
      <context:component-scan base-package="com.alex" />

      <!-- Step 4: Add support for conversion formatting and validation-->
      <mvc:annotation-driven />

      <!-- Step 5: Define Spring MVC view resolver-->
      <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/view" />
        <property name="suffix" value=".jsp "/>
      </bean>

    </beans>
    ```
    
 **View Resolver Configs - Explained**
- When your app provides a "view" name, Spring MVC will
    - prepend the prefix
    - append the suffix
```xml
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/view" />
    <property name="suffix" value=".jsp "/>
</bean>
```   

-----

**How to configure the Spring Dispatcher Servlet using all Java Code (no xml)**
https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/5614514#content

----- 
    
    





----------------------
*Skipping to the Spring Boot section
---------------------
    
**Spring Boot**

**The Problem**
    - Building a Spring app is really hard.
    Q: What Maven archetype to use?
    Q: Which Maven dependencies do I need?
    Q: How do I set up configuration (xml or Java)?
    Q: How do I install the server? (Tomcat, JBoss, etc...)

    - Tons of configuration
    - Very error-prone
    - Easy to make a simple mistake

**Spring Boot Solution**
    - Makes it easier to get started with Spring Development
    - Minimize the amount of manual configuration
        - Perform auto-configuration based on props files and JAR classpath
    - Help to resolve dependency conflicts (Maven or Gradle)
    - Provide an embedded HTTP server so you can get started quickly
        - Tomcat, jetty, etc

**Spring Initializr**
    - Quickly create a starter Spring project
    - Select your dependencies
    - Creates a Maven/Gradle project
    - Import the project into your IDE
        - Eclipse, IntelliJ, NetBeans etc...

**Spring Boot Embedded Server**
    - Provide an embedded HTTP server so you can get started quickly
        - Tomcat, Jetty, Undertow, ...
    - No need to install a server separately  
    
    
    
**Running Spring Boot Apps**
    - Spring Boot apps can be run standalone (includes embedded server)
    - Run the Spring Boot app from the IDE or command-line
    `> java -jar mycoolapp.jar`

**Deploying Spring Boot Apps**
    - Spring Boot apps can also be deployed in the traditional way
    - Deploy **WAR file** to an external server: Tomcat, JBoss, WebSphere etc...
    
**Spring Boot FAQ #1**
    Q: Does Spring Boot replace Spring MVC, Spring REST etc...?
    A: No. Spring Boot actually use those technologies.

    
    
**Spring Boot - Development Process**
    1) Configure our project at Spring Initializr website (http://start.spring.io)
    2) Download the zip file
    3) Unzip the file
    4) Import Maven project into our IDE


**Developing a REST API Controller with Spring Boot**
    - Let's create a very simple REST controller

    **Create REST Controller**
    ```java
    @RestController
    public class FunRestController {

      // expose "/" that returns "Hello World"
      @GetMapping("/")
      public String sayHello() {
        return "Hello World! Time on server is: " + LocalDateTime.now();
      }

    }
    ```
    
**Maven Standard Directory Structure**
    **Directory | Description**
        src/main/java **|** Your java source code
        src/main/resources **|** Properties / config files used by your app
        src/test/java **|** Unit testing source code
    
**Maven Wrapper Files**
    - **mvnw** allows you to run a Maven project
        - No need to have Maven installed or present on your path
        - If correct version of Maven is NOT found on your computer
            - **Automatically downloads** correct version and runs Maven
    - Two files are provided
        - mvnw.cmd for MS Windows `mvnw clean compile test`
        - mvnw.sh for Linux/Mac `./mvnw clean compile test`
    -If you already have maven, then ignore or delete those files. You can run mvn normally `mvn clean compile test`    
        
**Maven POM File**
    - **pom.xml** includes info that you entered at Spring Initializr website
    


**Annotations**
    - **@SpringBootApplication** is composed of the following annotations:
        @EnableAutoConfiguration: Enables Spring Boot's auto-configuration support.
        @ComponentScan: Enables component scan of current package. Also recursively scans sub-packages.
        @Configuration: Able to register extra Beans with @Bean or import other configuration classes.
    

**More on Component Scanning**
    Best Practice, Place your main application class in the root package above your other packages
    - This implicitly defines a base search package
        - Allows you to leverage default component scanning
        - No need to explicitly reference the base package name
    
    
    
**Application Properties**
    - By default, Spring Boot will load properties from: **application.properties** (Created by Spring Initializr and is empty at the beginning)
        - Can add Spring Boot properties (server.pot=8585)
    
--------------

**Spring Boot Starters**

**The Problem**
- building a Spring App is really hard...
- Which Maven dependencies do I need?

**Why Is It So Hard?**
- It would be great if there was a simple list of Maven dependencies
- Collected as a group of dependencies... one-stop-shop
- So I don't have to search for each dependency
- There should be an easier solution...

**The Solution - Spring Boot Starters**
- A curated list of Maven dependencies
- A collection of dependencies grouped together
- Tested and verified by the Spring Development team
- Makes it much easier for the developer to get started with Spring
- Reduces the amount of Maven configuration
    
**Spring Initializr**
- In Spring Initializr, simply select **Web** dependency
- You automatically get **spring-boot-starter-web** in **pom.xml**  
    
    
**What Is In the Starter?**
- FAQ: What is in **spring-boot-starter-xyz**?
- View the starter's POM file (www.luv2code.com/spring-boot-starters)
    - Normally references other starters... so you will need to dig a bit
- most IDEs have a __Dependency Management / View__ feature

For Eclipse Users
- Open the pom.xml
- Select the tab Dependency Hierarchy
- Expand the desired starter

For IntelliJ users
- Select View > Tool Windows > Maven Projects > Dependencies
    
**Benefits of the Spring Boot Starter Parent**
- Default Maven configuration: Java version, UTF-encoding etc
- Dependency management
    - User version on parent only
    - **spring-boot-starter-*** dependencies inherit version from parent
- Default configuration of Spring Boot plugin
  
-------
    
**Spring Boot Dev Tools**

**The Problem**
- When running Spring Boot applications
    - If you make changes to your source code
    - Then you have to manually restart your application

**Solution: Spring Boot Dev Tools**
- Automatically restart your application when code is updated
- Simply add the dependency to your POM file
- No need to write additional code!

-Adding the dependency to your POM file 
```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-devtools</artifactId>
</dependency>
```
    
**Development Process**
1) Edit **pom.xml** and add **spring-boot-devtools**
2) Add new REST endpoint to our app
3) Verify the app is automatically reloaded    
    
    
**--------------------**
**Spring Boot Actuator**

**Problem**
    - How can I monitor and manage my application?
    - How can i check the application health?
    - How can I access application metrics?

**Solution: Spring Boot Actuator**
    - Exposes endpoints to monitor and manage your application
    - You easily get DevOps functionality out-of-the-box
    - Simply add the dependency to your POM file
    - REST endpoints are __automatically__ added to your application
    - *No need to write additional code. You get new REST endpoints for free.*

    - Adding the dependency to your POM file
    ```xml
    <dependency>
      <groupId>org.springframework.boot<groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    ```

    - Automatically exposes endpoints for metrics out-of-the-box
    - Endpoints are prefixed with: **/actuator**

    /health - Health information about your app
    /info - Information about your project
    
**Health Endpoint**
    - /health checks the status of your app
    - Normally used by monitoring apps to see if your app is up or down
    `localhost:8080/actuator/health`
    `{"status" : "UP"}`
    - Health status is customizable based on your custom business logic

**Info Endpoint**
    - /info gives information about your application
    - Default is empty
    `localhost:8080/actuator/info`
    `{}`

    - Update **application.properties** with your app info
    File: src/main/resources/application.properties
    ```
    info.app.name=Cool App
    info.app.description=An amazing app
    info.app.version=1.0.0
    ```
    - will send back a JSON


**Spring Boot Actuator Endpoints**
- There are 10+ Spring Boot Actuator endpoints
- /auditevents - audit events for your app
- /beans - List of all beans registered in the Spring application context
- /mappings - List of all @RequestMapping paths
...
http://www.luv2code.com/actuator-endpoints

**Exposing Endpoints**
- By default, only **/health** and **/info** are exposed
- To expose all actuator endpoints over HTTP
File: src/main/resources/application.properties
```properties
# Use wildcard "*" to expose all endpoints
# Can also expose individual endpoints with a comma-delimited
# 
management.endpoints.web.exposure.include=*
```

**Get A List of Beans**
- Access http://localhost:8080/actuator/beans


**Development Process**
1) Edit **pom.xml** and **spring-boot-starter-actuator**
2) View actuator endpoints for: **/health** and **/info**
3) Edit application.properties to customize **/info**

    
    
    
**Spring Boot Actuator - Applying Security to Actuator Endpoints**
What about Security?
- You may NOT want to expose all of this information
- Add Spring Security to project and endpoints are secured
```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  </artifactId>spring-boot-starter-security</artifactId>
</dependency>
```
/health and /info are still available 
You can disable them if you want

**Secured Endpoints**
- Now when you access /actuator/beans
- Spring Security will prompt for login
*Default username: **user***
*Check console logs for password*
    
    
**Spring Security configuration**
- You can override default user name and generated password
File: src/main/resources/application.properties
```properties
spring.security.user.name=alex
spring.security.user.password=asdf
```
**Customizing Spring Security**
- You can customize Spring Security for Spring Boot Actuator
    - Use a database for roles, encrypted passwords, etc...
- Follow the same techniques as regular Spring Security
```java
public class DemoSecurityConfig extends WebSecurityConfigurerAdapter {
  @Autowired
  private DataSource securityDataSource;

  @Override
  protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.jdbcAuthentication().dataSource(securityDataSource);
  }
  ...
}
```

**Excluding  Endpoints**
- To exclude /health and /info
File: src/main/resources/application.properties
```properties
# Exclude individual endpoints with a comma-delimited list
#
management.endpoints.web.exposure.exclude=health,info
```

**Development Process**
1) Edit **pom.xml** and add **spring-boot-starter-security**
2) Verify security on actuator endpoints for: **/beans** etc...
3) Disable endpoints for **/health** and **/info**
    
    
    
**---------------**
**Running from the Command-Line**
- Since we are using Spring Boot, the server is embedded in our JAR file
- No need to have a separate server installed/running
- Spring Boot apps are self contained
    - JAR file includes your application code AND includes the server
    - Self-contained unit and nothing else to install

Option 1: Use `java -jar mycoolapp.jar`

Option 2: Use Spring Boot Maven plugin `mvnw spring-boot:run`

**Development Process**
1) Exit the IDE
2) Package the app using `mvnw package`
3) Run app using `java -jar`
or
4) Run app using Spring Boot Maven plugin, `mvnw spring-boot:run`
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    