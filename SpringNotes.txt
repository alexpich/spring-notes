Spring Notes

Goals of Spring
    - Lightweight development with Java POJOS
    - Dependency injection to promote loose coupling
    - Declarative programming with Aspect-Oriented-Programming (AOP)
    - Minimize boilerplate Java code

Core Container
    1) Beans
    2) Core
    3) SpEL
    - Spring Expression Language
    4) Context

Summary:
    - Factory for creating beans
    - Manage bean dependencies

Infrastructure
    1) AOP
    2) Aspects
    3) Instrumentation
    4) Messaging

    Summary:
    - Aspect Oriented Programming (Logging, security, transactions, instrumentations, etc that you can apply these services to your objects in a declarative fashion )
    
Data Access Layer
    1) JDBC
    2) ORM
    3) Transactions
    4) OXM
    5) JMS

    Summary: 
    - Communicating with databases.
    - JDBC Helper classes (can reduce your jdbc code by 50%).
    - ORM to relational Mapping and Integration with Hibernate and JPA
    - Java Message Service allows you to send messages to a message queue asynchronously (many helper classes to reduce code by 50%)
    
Web Layer
    1) Servlet
    2) WebSocket
    3) Web
    4) Portlet

    Summary: 
    - All web related classes
    - Home of the Spring MVC module
    
    
Spring Projects
    - Additional Spring modules built-on top of the core Spring Framework
    - Only use what you need...
    - Spring Cloud, Spring Data
    - Spring Batch, Spring Security
    - Spring for Android, Spring Web Flow
    - Spring Web Services, Spring LDAP
    
Tomcat
    MacOS Installation
        1) Download the .tar
        2) Install it
        3) Unzip and move it to your preferred directory
        4) cd in to the directory
        5) bin/startup.sh (to start the server)
        6) go to localhost:8080
        7) bin/shutdown.sh (to shut down server)
        
Spring Jar files
    https://repo.spring.io/release/org/springframework/spring/
    This method does not require Maven. Download the dist and save it somewhere on your computer. Go to lib and copy all the JARs and then make a new folder called lib in Eclipse. Paste the JARs in that new folder. Then go to the project properties by right clicking and hitting properties on the main folder. Go to Java Build Path, Librariers, Add JARS.
    
Inversion of Control
    This is important!
    - The approach of outsourcing construction and management of objects.
    
Spring Container
    1) Primary functions
    - Create and manage objects (Inversion of Control)
    - Inject object's dependencies (Dependency Injection)

Configuring Spring Container
    1) XML configuration file (legacy, but most legacy apps still use this)
    2) Java Annotations (modern)
    3) Java Source Code (modern)
    Spring Development Process
    1) Configure your Spring Beans
    2) Create a Spring Container
    3) Retrieve Beans from Spring Container
    
    Step 1: Configure your Spring Beans
        File: applicationContext.xml

        <beans ...>
          <bean id="myCoach"     
        class="com.luv2code.springdemo.BaseballCoach">
          </bean>
        </beans>
        
Step 2: Create a Spring Container 
    - Spring container is generically known as ApplicationContext
    - Specialized implementations
    -- ClassPathXmlApplicationContext
    -- AnnotationConfigApplicationContext
    -- GenericWebApplicationContext
    -- others...

    Ex) 
      ClassPathXmlApplicationContext context = new ClassPAthXmlApplicationContext("applicationContext.xml");
      
Step 3: Retrieve Beans from Container
    // create a spring container
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

    // retrieve bean from spring container, the id must match what we are passing in... myCoach
    Coach theCoach = context.getBean("myCoach", Coach.class);
    
    The first argument is the id in applicationContext.xml and the second argument is the Interface
    
FAQ: What is a Spring Bean?

A "Spring Bean" is simply a Java object.

When Java objects are created by the Spring Container, then Spring refers to them as "Spring Beans".

Spring Beans are created from normal Java classes .... just like Java objects.


---

In the early days, there was a term called "Java Beans". Spring Beans have a similar concept but Spring Beans do not follow all of the rigorous requirements of Java Beans.

---


Dependency Injection
    - The dependency inversion principle.
    - The client delegates to calls to another object the responsibility of providing dependencies.
    Basically...
    1) Give me a "Car" object
    ->
    2) Car Factory, technicians will assemble the car for you. They will inject all the "dependency" (same thing as "helper objects") for you.
    3) Give "Car" to you

    Summary: You simply outsource the construction to an external entity.
    
Injection Types
    - There are many types of injection with Spring
    - We will cover the two most common:
    1) Constructor Injection
    2) Setter Injection
    - Autowiring will come later...

-----------------
    
Development Process - Contructor Injection
    1) Define the dependency interface and class
    2) Create a constructor in your class for injections
    3) Configure the dependency injection in Spring config file    

Step 1: Define the dependency interface and class
    File: FortuneService.java
     public interface FortuneService {
      public String getFortune();
    }

    File: HappyFortuneService.java
      public class HappyFortuneService implements FortuneService {
      public String getFortune() {
        return "Today is your lucky day!";
      }
    }


Step 2: Create a constructor
    File: BaseballCoach.java
    public class BaseballCoach implements Coach {

      // define field
      private FortuneService fortuneService;

      // define constructor
      public BaseballCoach(FortuneService theFortuneService) {
        fortuneService = theFortuneService;
      }
    }
    
Step 3: Configure the dependency injection in Spring config file
    File: applicationContext.xml
    <bean id="myFortuneService" class="com.alex.HappyFortuneService">
    </bean>

    <bean id="myCoach" class="com.alex.BaseballCoach">
      <cosntructor-arg ref="myFortuneService" />
    </bean>

    a) Define the dependency/helper
    b) Inject that dependency into our class using ref (constructor injection)
    
-----------------
    
Setter Injection
    - Inject dependencies by calling setter method(s) on your class
    
Development Process - Setter Injection
    1) Create setter method(s) in your class for injections
    2) Configure the dependency injection in Spring config file
    
Step 1: Create the setter method(s) in your class for injections
    File: CricketCoach.java
    public class CricketCoach implements Coach {
      private FortuneService fortuneService;

      public CricketCoach() {
      }

      // Called by Spring during setter injection
      public void setFortuneService(FortuneService fortuneService) {
        this.fortuneService = fortuneService;
      }

    }
    
**Step 2: Configure the dependency injection in Spring config file**
    ```xml
    <bean id="myFortuneService" class="com.alex.HappyFortuneService">
    </bean>

    <bean id="myCricketCoach" class="com.alex.CricketCoach">
      <property name="fortuneService" ref="myFortuneService"/>
    </bean>
    ```
    
**How Spring Processes your Config File**
```xml
<bean id="myFortuneService" class="com.alex.HappyFortuneService">
</bean>
```
-> Spring Framework
```java
HappyFortuneService myFortuneService = new HappyFortuneService();
```

-----------------

**Injecting Literal Values**
    Example... injecting strings such and team name or email address into the CricketCoach
    **Development Process**
    1) Create setter method(s) in your class for injections
    2) Configure the injection in Spring config file

**Step 1:**
```java
public class CricketCoach implements Coach {
  private String emailAddress;
  private String team;

  // Create Setter methods
  public void setEmailAddress(String emailAddress) {
    // ....
  }
  public void setTeam(String team) {
    // ...
  }
}
```

**Step 2:**
```xml
 <bean id="myCricketCoach" class="com.alex.CricketCoach">
  <property name="fortuneService" ref="myFortuneService" />
  <property name="emailAddress" value="alex@email.com" />
  <property name="team" value="Team One" />
 </bean>
```

**Injecting Values from a Properties File**
1) Create Properties File
2) Load Properties File in Spring config file
3) Reference values from Properties File

**Step 1:**
File: sport.properties
name and value pairs
```
foo.email=alex@email.com
foo.team=Extreme Challengers
```

**Step 2: **
File: applicationContext.xml
```xml
  <context:property-placeholder location="classpath:sport.properties" />
```

**Step 3:**
File: applicationContext.xml
```xml
<bean id="myCricketCoach" class="com.alex.CricketCoach">
...
<property name="emailAddress" value="${foo.email}" />
<property name="team" value="${foo.team}" />
</bean>
```

-----------------

**Bean Scopes**
- Scope refers to the lifecycle of a bean
- How long does the bean live?
- How many instances are created?
- How is the bean shared?

**Default Scope: Singleton**
```xml
<beans .../>
  <bean id="myCricketCoach" class="com.alex.CricketCoach" ...>
  </bean>
</bean>
```

**What Is a Singleton?**
- Spring Container creates only one instance of the bean, by default
- It is cached in memory
- All requests for the bean will return a SHARED reference to the SAME bean

Best used when you want stateless beans aka don't maintain any state.

**Explicitly Specify Bean Scope**
```xml
<beans .../>
  <bean id="myCricketCoach" class="com.alex.CricketCoach" scope="singleton">
  </bean>
</bean>
```

**Prototype Scope Example**
Prototype scope: new object for each request
```xml
<beans ...>
  <bean id="myCoach" class="com.alex.TrackCoach" scope="prototype">
  ...
  </bean>
</beans
```
Good for keeping track of stateful data.

-----------------

Bean Lifecycle
    1) Container Started
    2) Bean Instantiated
    3) Dependencies Injected
    4) Internal Spring Processing
    5) Your Custom Init Method
    6) Bean is Ready For Use / Container Is Shutdown
    7) Your Custom Destroy Method
    8) STOP
    
Bean Lifecycle Methods / Hooks
    - You can add custom code during bean initialization
      - Calling custom business logic methods
      - Setting up handles to resources (db, sockets, file, etc)
    - You can add custom code during bean destruction
      - Calling custom business logic methods
      - Setting up handles to resources (db, sockets, file, etc)
      
**Init: method configuration**
    ```xml
    <beans ...>
      <bean id="myCoach" class="com.alex.TrackCoach" init-method="doMyStartupStuff" ...>
      </bean>
    </beans>
    ```

**Destroy: method configuration**
    ```xml
    <beans ...>
      <bean id="myCoach" class="com.alex.TrackCoach" destroy-method="doMyStartupStuff" ...>
      </bean>
    </beans>
    ```
    
Development Process
    1) Define your methods for init and destroy
    2) Configure the method names in Spring config file
    
    
Special Note about init and destroy Method Signatures

    When using XML configuration, I want to provide additional details regarding the method signatures of the init-method  and destroy-method .

    Access modifier
    The method can have any access modifier (public, protected, private)

    Return type
    The method can have any return type. However, "void' is most commonly used. If you give a return type just note that you will not be able to capture the return value. As a result, "void" is commonly used.

    Method name
    The method can have any method name.

    Arguments
    The method can not accept any arguments. The method should be no-arg.   

------

**What are Java Annotations?**
    - Special labels/markers added to Java classes
    - Provide meta-data about the class
    - Processed at compile time or run-time for special processing


**Why Spring Configuration with Annotations?**
    - XML configuration can be verbose
    - Configure your Spring beans with Annotations
    - Annotations minimizes the XML configuration
    
**Scanning for Component Classes**
    - Spring will scan your Java classes for special annotations
    - Automatically register the beans in the Spring container
    
**Development Process**
    1) Enable component scanning in Spring config file
    2) Add the @Component Annotation to your Java classes
    3) Retrieve bean from Spring container

**Step 1:** 
```xml
<beans ...>
  <context:component-scan base-package="com.alex" />
</beans>
```

**Step 2**
```java
@Component("thatSillyCoach")
public class TennisCoach implements Coach {
  @Override
  public String getDailyWorkout() {
    return "Practice your backhand valley";
  }
}
```

**Step 3**
    - Same coding as before... nothing changes.
    ```java
    Coach theCoach = context.getBean("thatSillyCoach", Coach.class);
    ```

    Spring also supports Default Bean IDs
    - Default bean id: the class name, make first letter lower-case

    Class Name
    TennisCoach

    ->

    Default Bean Id
    tennisCoach
    
------
    
**What is Spring AutoWiring?**
- For dependency injection, Spring can use auto wiring.
- Spring will look for a class that *matches* the property
    - *matches* by type: class or interface
- Spring will inject it automatically... hence it is autowired

**Autowiring Example**
- Injecting FortuneService into a Coach implementation
- Spring will scan @Components
- Any one implements FortuneService interface???
- If so, let's inject them. For example: HappyFortuneService

**Autowiring Injection Types**
- Constructor Injection
- Setter Injection
- Field Injections

**Development Process - Constructor Injection**
1) Define the dependency interface and class
2) Create a constructor in your class for injections
3) Configure the dependency injection with @Autowired Annotation
    
**Step 1:**
File: FortuneService.java
```java
public interface FortuneService {
  public String getFortune();
}
```
File: HappyFortuneService.java
```java
@Component
public class HappyFortuneService implements FortuneService {
  public String getFortune() {
    return "Today is your lucky day!"
  }
}
```

**Step 2**
File: TennisCoach.java
```java
@Component
public class TennisCoach implements Coach {
  private FortuneService fortuneService;

  public TennisCoach(FortuneService theFortuneService) {
    fortuneService = theFortuneService;
  }
}
```

**Step 3**
File: TennisCoach.java
```java
@Component
public class TennisCoach implements Coach {
  private FortuneService fortuneService;

  @Autowired
  public TennisCoach(FortuneService theFortuneService) {
    fortuneService = theFortuneService;
  }
}
```

------
AUTOWIRING
FAQ: What if there are multiple FortuneService implementations?

When using autowiring, what if there are multiple FortuneService implementations? Like in the image below?
---
ANSWER

Spring has special support to handle this case. Use the @Qualifier annotation.

---------


**Setter Injection**
- Inject dependencies by calling setter method(s) on your class

**Autowiring Example**
- Injecting FortuneService into a Coach implementation
- Spring will scan @Components
- Any one implements FortuneService interface???
- If so, let's inject them. For example: *HappyFortuneService*
    
**Development Process - Setter Injection**
    1) Create setter method(s) in your class for injections
    2) Configure the dependency injection with @Autowired Annotation

    **Step 1**
    File: TennisCoach.java
    ```java
    @Component
    public class TennisCoach implements Coach {
      private FortuneService fortuneService;

      public TennisCoach() {
      }

      public void setFortuneService(FortuneService fortuneService) {
        this.fortuneService = fortuneService;
      }
      ...
    }
    ```

    **Step 2**
    File: TennisCoach.java
    ```java
    @Component
    public class TennisCoach implements Coach {
      private FortuneService fortuneService;

      public TennisCoach() {
      }

      @Autowired
      public void setFortuneService(FortuneService fortuneService) {
        this.fortuneService = fortuneService;
      }
      ...
    }
    ```

**Method Injection**
    - Inject dependencies by calling ANY method on your class

    Simply give: 
    ```java
    @Autowired
    ```

    **Step 2**
    File: TennisCoach.java
    ```java
    @Component
    public class TennisCoach implements Coach {
      private FortuneService fortuneService;

      public TennisCoach() {
      }

      @Autowired
      public void doSomeCrazyStuff(FortuneService fortuneService) {
        this.fortuneService = fortuneService;
      }
      ...
    }
    ```
    
---------------

**Field Injection with Annotations and Autowiring**
    - Inject dependencies by setting field values on your class directly (even private fields)
    - Accomplished by using Java Reflection

**Development Process - Field Injection**
    1) Configure the dependency injection with Autowired Annotation
    - Applied directly to the field
    - No need for setter methods

**Step 1**
    File: TennisCoach.java
    ```java
    public class TennisCoach implements Coach {
      @Autowired
      private FortuneService fortuneService;

      public TennisCoach() {
      }

      // no need for setter methods
      ...
    }
    ```

    
-----------
**Multiple FortuneService Implementations**
    Solution: Be specific - @Qualifier
        ```java
        public class TennisCoach implements Coach {

          @Autowired
          @Qualifier("happyFortuneService")
          private FortuneService fortuneService;

          ...
        }
        ```

**Injection Types**
Can apply **@Qualifier** annotation to:
- Constructor Injection
- Setter injection methods
- Field injection

---------
**Explicitly Specify Bean Scope**
    ```java
    @Component
    @Scope("singleton")
    public class TennisCoach implements Coach{
    }
    ```
**Bean Lifecycle Method Annotations**
Development Process
    1) Define your methods for init and destroy
    2) Add annotations: @PostConstruct and @PreDestroy

Java 9 + Errors with @PostConstruct and @PreDestroy
    https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/9120288#content

**Special Note about Destroy Lifecycle and Prototype Scope**
Here is a subtle point you need to be aware of with "prototype" scoped beans.

For "prototype" scoped beans, Spring does not call the @PreDestroy method.  Gasp!  
https://www.udemy.com/course/spring-hibernate-tutorial/learn/lecture/5389290#content   
    
    
    
------------
    
**Spring Configuration with Java Code**
    - No XML
    - Configure Spring Container with Java

**3 Ways of Configuring Spring Container**
    1) Full XML Config
    2) XML Component Scan
    3) Java Configuration Class

**Development Process**
    1) Create a Java class and annotate as **@Configuration**
    2) Add component scanning support **@ComponentScan** (optional)
    3) Read Spring Java configuration class
    4) Retrieve bean from Spring container
    
    **Step 1:**
    ```java
    @Configuration
    public class SportConfig {
    }
    ```
    **Step 2:**
    ```java
    @Configuration
    @ComponentScan("com.alex")
    public class SportConfig {
    }
    ```
    **Step 3:**
    In our main
    ```java
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SportConfig.class);
    ```
    **Step 4:**
    ```java
    Coach theCoach = context.getBean("tennisCoach", Coach.class);
    ```
------------------- 
    
**Defining Spring Beans with Java Code**

**Development Process**
1) Define method to expose bean
2) Inject bean dependencies
3) Read Spring Java configuration class
4) Retrieve bean from Spring container

**Step 1**
No component scan. Define each bean individually.
```java
@Configuration
public class SportConfig() {

  @Bean
  public Coach swimCoach() {
    SwimCoach mySwimCoach = new SwimCoach();

  return mySwimCoach;
  }
}
```
**Step 2**
```java
@Configuration
public class SportConfig() {

  // Create instance of HappyFortuneService and return it
  @Bean
  public FortuneService happyFortuneService() {
    return new HappyFortuneService();
  }

  // Inject happyFortuneService
  @Bean
  public Coach swimCoach() {
    SwimCoach mySwimCoach = new SwimCoach(happyFortuneService());

  return mySwimCoach;
  }
}
```
**Step 3**
```java
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SportConfig.class); 
```
**Step 4**
The beanId "swimCoach" is the method name we defined in the Bean.
```java
Coach theCoach = context.getBean("swimCoach", Coach.class);
```

--------------
**Injecting Values from Properties File**

**Development Process**
1) Create Properties File
2) Load Properties File in Spring config
3) Reference values from Properties File

**Step 1**
File: sport.properties
```
foo.email=alex@email.com
foo.team=Awesome Java Coders
```
**Step 2**
Load the props file
```java
@Configuration
@PropertySource("classpath:sport.properties")
public class SportConfig {
  ...
}
```
**Step 3**
File: SwimCoach.java
```java
public class SwimCoach implements Coach {
  @Value("${foo.email}")
  private String email;

  @Value("${foo.team}")
  private String team;
  
  ...
}
```
    
---------------


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    